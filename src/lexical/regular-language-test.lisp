(in-package :burning-lexical-test)

(defcase reglang-test)

(defun char-node (char)
  (range-node char char))

(defun not-a-regular-expression-error (expression)
  (let ((output (make-string-output-stream)))
    (format output "Regular expression must be a list. ~a" expression)
    (get-output-stream-string output)))

(defun wrong-type-error (function-name position expected-type type)
  (let ((output (make-string-output-stream)))
    (format output 
	    "~a-th argument for ~a must be ~a, not ~a." 
	    position 
	    (write-to-string function-name)
	    expected-type
	    type)
    (get-output-stream-string output)))

(deftest reglang-test char-test ()
  (!node= (:char #\a)
	  (char-node #\a)))

(deftest reglang-test range-test ()
  (!node= (:range #\a #\b)
	  (range-node #\a #\b)))

(deftest reglang-test or-test ()
  (!node= (:or (:char #\a) (:range #\b #\c))
	  (or-node (character-node #\a) (range-node #\b #\c))))

(deftest reglang-test empty-test ()
  (!node= (:empty)
	  (empty-node)))

(deftest reglang-test to-range-set-test ()
  (!equal (to-range-set (character-node #\a))
	  '((#\a . #\a)))
  (!equal (to-range-set (range-node #\a #\e))
	  '((#\a . #\e)))
  (!equal (to-range-set (or-node (range-node #\a #\b)
				 (range-node #\d #\e)))
	  '((#\a . #\b) (#\d . #\e)))
  (!equal (to-range-set (or-node (range-node #\d #\e)
				 (range-node #\a #\b)))
	  '((#\a . #\b) (#\d . #\e)))
  (!equal (to-range-set (or-node (range-node #\a #\c)
				 (range-node #\b #\d)))
	  '((#\a . #\d)))
  (!equal (to-range-set (or-node (or-node (range-node #\a #\d)
					  (range-node #\f #\h))
				 (or-node (range-node #\b #\c)
					  (or-node (range-node #\f #\l)
						   (range-node #\o #\z)))))
	  '((#\a . #\d) (#\f . #\l) (#\o . #\z)))
  (!equal (to-range-set (or-node (range-node #\a #\b)
				 (range-node #\c #\d)))
	  '((#\a . #\d)))
  (!equal (to-range-set (empty-node))
	  '())
  (!equal (to-range-set (or-node (or-node (range-node #\a #\b)
					  (range-node #\d #\e))
				 (range-node #\b #\d)))
	  '((#\a . #\e))))

(deftest reglang-test not-test ()
  (!node= (:not (:or (:range #\b #\f) 
		     (:range #\B #\F))
		:full-range (:or (:range #\a #\z)
				 (:range #\A #\Z)))
	  (or-node (range-node #\A #\A)
		   (or-node (range-node #\G #\Z)
			    (or-node (range-node #\a #\a)
				     (range-node #\g #\z)))))
  (let ((node (:or (:range #\a #\d)
		   (:range #\f #\g))))
    (!node= (:not (:not node)) node)))

(deftest reglang-test letter-test ()
  (!node= (:letter)
	  (or-node (range-node #\a #\z)
		   (range-node #\A #\Z)))
  (!node= (:letter :no-upper t)
	  (range-node #\a #\z))
  (!node= (:letter :no-lower t)
	  (range-node #\A #\Z))
  (!node= (:letter :languages '(en ru))
	  (or-node (or-node (range-node #\a #\z)
			    (range-node #\A #\Z))
		   (or-node (range-node #\а #\я)
			    (range-node #\А #\Я)))))

(deftest reglang-test positive-test ()
  (!node= (:positive (:char #\a))
	  (and-node (character-node #\a)
		    (star-node (character-node #\a)))))

(deftest reglang-test repeat-test ()
  (!node= (:repeat (:char #\a) 3 3)
	  (and-node (character-node #\a)
		    (and-node (character-node #\a)
			      (character-node #\a))))
  (!node= (:repeat (:char #\a) 0 2)
	  (and-node (or-node (empty-node) (character-node #\a))
		    (or-node (empty-node) (character-node #\a))))
  (!node= (:repeat (:char #\a) 1 2)
	  (and-node (character-node #\a)
		    (or-node (empty-node) (character-node #\a)))))
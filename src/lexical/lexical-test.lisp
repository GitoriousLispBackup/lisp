(in-package :burning-lexical-test)

(defcase lexical-test)

(deftest lexical-test lexical-making ()
  (let* ((lexeme1 (make-lexeme 'sample1 '("s1")))
	 (lexeme2 (make-lexeme 'sample2 '("s2")))
	 (lexic (make-lexic lexeme1 lexeme2)))
    (!equalp (expression lexic) '(or (and (and (3 0) (0 1)) (burning-lexical::final sample1 2))
				     (and (and (3 3) (1 4)) (burning-lexical::final sample2 5))))
    (!equalp (translation lexic) '(((#\1 . #\1) 0) ((#\2 . #\2) 1) ((#\3 . #\r) 2) ((#\s . #\s) 3)))
    (!equalp (follow-vector lexic) (make-array 6))
    (!equalp (value-vector lexic) (make-array 6))
    (!equalp (next-vector lexic) (make-array 6))))

(deftest lexical-test deflexeme-test ()
  (!equal (macroexpand-1 '(deflexeme if ("if")))
	  '(defparameter if (make-lexeme 'if '("if")))))

(deftest lexical-test nullable-test ()
  (!eq (nullable (regular-to-tree '((- "a" "d")))) nil)
  (!eq (nullable (regular-to-tree '((* "a")))) t)
  (!eq (nullable (regular-to-tree '((? "ab")))) t)
  (!eq (nullable (regular-to-tree '((* "ab") (? "cd") "ef"))) nil)
  (!eq (nullable (regular-to-tree '((* "ab") (? "cd") (|| "ef" "gh" (? "ij"))))) t)
  (!eq (nullable '(burning-lexical::final end)) nil))

(deflexeme if ("if"))
(deflexeme then ("then"))
(deflexeme word ((+ (- "a" "z"))))
(deflexeme integer ((? (|| "-" "+")) (+ (- "0" "9"))))
(deflexeme spaces ((* " ")))
(deflexeme r-word ((+ (- "а" "я"))))

(deftest lexical-test first-test ()
  (!equal (first-pos (expression (make-lexic if))) '(0))
  (!equal (first-pos (expression (make-lexic word))) 
          '(0))
  (!equal (first-pos (expression (make-lexic integer)))
	  '(0 1 2))
  (!equal (first-pos (expression (make-lexic spaces)))
	  '(0 1)))

(deftest lexical-test last-test ()
  (!equal (last-pos (expression (make-lexic if))) '(2))
  (!equal (last-pos (expression (make-lexic (second word))))
	  '(0 1))
  (!equal (last-pos (expression (make-lexic (second integer))))
	  '(2 3)))

(deflexic sample-lexic (make-lexeme 'sample '((* (- "a" "b")) "abb")))
(deflexic my-lexic if then word integer spaces r-word)

(deftest lexical-test follow-test ()
  (!equalp (follow-vector sample-lexic)
	   #((0 1 2) (0 1 2) (3) (4) (5) ())))

(deftest lexical-test lexic-generation ()
  (!equalp (expression sample-lexic) '(and (and (burning-lexical::star (or (0 0) (1 1)))
   					        (and (0 2) (and (1 3) (1 4))))
				           (burning-lexical::final sample 5)))
  (!equalp (follow-vector sample-lexic) #((0 1 2) (0 1 2) (3) (4) (5) ()))
  (!equalp (value-vector sample-lexic) #(nil nil nil nil nil sample))
  (!equalp (next-vector sample-lexic) #(0 1 0 1 1 nil)))

(deftest lexical-test state-machine-creating ()
  (let ((machine (create-state-machine sample-lexic)))
    (!equalp (slot-value machine 'values)
	     #(nil nil nil sample))
    (!equalp (slot-value machine 'transitions)
	     #(((0 . 1) (1 . 0))
	       ((0 . 1) (1 . 2))
	       ((0 . 1) (1 . 3))
	       ((0 . 1) (1 . 0))))))

(deftest lexical-test state-machine-value ()
  (let ((machine (create-state-machine my-lexic)))
    (!eq (machine-value machine "if") 'if)
    (!eq (machine-value machine "then") 'then)
    (!eq (machine-value machine "abbasgheqtaba") 'word)
    (!eq (machine-value machine "213548906") 'integer)
    (!eq (machine-value machine "+11412341230") 'integer)
    (!eq (machine-value machine "-110111235123451451450") 'integer)
    (!eq (machine-value machine "анализатор") 'r-word)
    (!eq (machine-value machine "") 'spaces)
    (!eq (machine-value machine "    ") 'spaces)))

(in-package :burning-lexical-test)

(defcase core-test)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defmacro !node= (node1 node2)
    `(equal-check ,node1 ,node2 node=)))

(defun irange-node (range position)
  (make-instance 'burning-lexical::integer-range-node :range range :position position))
(defun p-final-node (lexeme position)
  (make-instance 'burning-lexical::final-node 
		 :lexeme lexeme
		 :position position))

(deftest core-test lexical-making ()
  (let* ((lexeme1 (make-lexeme 'sample1 (:and (:char #\s) (:char #\1))))
	 (lexeme2 (make-lexeme 'sample2 (:and (:char #\s) (:char #\2))))
	 (lexic (make-lexic lexeme1 lexeme2)))
    (!node= (expression lexic) 
	    (or-node (and-node (and-node (irange-node 3 0) (irange-node 0 1))
			       (p-final-node lexeme1 2))
		     (and-node (and-node (irange-node 3 3) (irange-node 1 4)) 
			       (p-final-node lexeme2 5))))
    (!equalp (translation lexic) '(((#\1 . #\1) 0) ((#\2 . #\2) 1) ((#\3 . #\r) 2) ((#\s . #\s) 3)))
    (!equalp (follow-vector lexic) (make-array 6))
    (!equalp (value-vector lexic) (make-array 6))
    (!equalp (next-vector lexic) (make-array 6))))


(deftest core-test nullable-test ()
  (!eq (nullable (:range #\a #\d)) nil)
  (!eq (nullable (:star (:char #\a))) t)
  (!eq (nullable (:maybe (:and (:char #\a) (:char #\b)))) t)
  (!eq (nullable (:and (:star (:and (:char #\a) (:char #\b)))
		       (:and (:maybe (:and (:char #\c) (:char #\d)))
			     (:and (:char #\e) (:char #\f)))))
       nil)
  (!eq (nullable (:and (:star (:and (:char #\a) (:char #\b)))
		       (:and (:maybe (:and (:char #\c) (:char #\d)))
			     (:or (:and (:char #\e) (:char #\f))
				  (:or (:and (:char #\g) (:char #\h))
				       (:maybe (:and (:char #\i) (:char #\j))))))))
       t)
  (!eq (nullable (final-node 'end)) nil))

(deflexeme if (:and (:char #\i) (:char #\f)))
(deflexeme then (:and (:char #\t)
		      (:and (:char #\h)
			    (:and (:char #\e)
				  (:char #\n)))))
(deflexeme word (:positive (:letter :no-upper t)))
(deflexeme integer (:and (:maybe (:or (:char #\-) (:char #\+)))
			 (:positive (:digit))))
(deflexeme spaces (:star (:char #\Space)))
(deflexeme r-word (:positive (:letter :no-upper t :languages '(ru))))

(deftest core-test first-test ()
  (!equal (first-pos (expression (make-lexic if))) '(0))
  (!equal (first-pos (expression (make-lexic word))) '(0))
  (!equal (first-pos (expression (make-lexic integer))) '(0 1 2))
  (!equal (first-pos (expression (make-lexic spaces))) '(0 1)))

(deftest core-test last-test ()
  (!equal (last-pos (expression (make-lexic if))) '(2))
  (!equal (last-pos (left-node (expression (make-lexic word))))
	  '(0 1))
  (!equal (last-pos (left-node (expression (make-lexic integer))))
	  '(2 3)))

(deflexeme sample-lexeme (:and (:star (:range #\a #\b))
			       (:and (:char #\a)
				     (:and (:char #\b)
					   (:char #\b)))))

(deflexic sample-lexic sample-lexeme)

(deftest core-test follow-test ()
  (!equalp (follow-vector sample-lexic)
	   #((0 1 2) (0 1 2) (3) (4) (5) ())))


(defmacro !oequal (expr1 expr2)
  `(equal-check ,expr1 ,expr2 oequal))

(deftest core-test lexic-generation ()
  (!node= (expression sample-lexic) 
	  (and-node (and-node (star-node (or-node (irange-node 0 0) 
						  (irange-node 1 1)))
			      (and-node (irange-node 0 2) 
					(and-node (irange-node 1 3) 
						  (irange-node 1 4))))
		    (p-final-node sample-lexeme 5)))
  (!equalp (follow-vector sample-lexic) #((0 1 2) (0 1 2) (3) (4) (5) ()))
  (!oequal (value-vector sample-lexic) 
	   (list nil nil nil nil nil sample-lexeme))
  (!equalp (next-vector sample-lexic) #(0 1 0 1 1 nil)))

(deflexeme c-string (:and (:char #\")
			  (:and (:star (:any))
				(:char #\"))) :minimal t)

(deflexic min-lexic c-string)

(deftest core-test minimal-lexic ()
  (!oequal (value-vector min-lexic) 
	   (list nil nil nil nil nil nil c-string)))

(in-package :burning-lexical-test)

(defcase core-test)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defmacro !node= (node1 node2)
    `(equal-check ,node1 ,node2 node=)))

(defun irange-node (range position)
  (make-instance 'burning-lexical::integer-range-node :range range :position position))
(defun p-final-node (lexeme position)
  (make-instance 'burning-lexical::final-node :lexeme lexeme :position position))

(deftest core-test lexical-making ()
  (let* ((lexeme1 (make-lexeme 'sample1 '("s1")))
	 (lexeme2 (make-lexeme 'sample2 '("s2")))
	 (lexic (make-lexic lexeme1 lexeme2)))
    (!node= (expression lexic) 
	    (or-node (and-node (and-node (irange-node 3 0) (irange-node 0 1))
			       (p-final-node 'sample1 2))
		     (and-node (and-node (irange-node 3 3) (irange-node 1 4)) 
			       (p-final-node 'sample2 5))))
    (!equalp (translation lexic) '(((#\1 . #\1) 0) ((#\2 . #\2) 1) ((#\3 . #\r) 2) ((#\s . #\s) 3)))
    (!equalp (follow-vector lexic) (make-array 6))
    (!equalp (value-vector lexic) (make-array 6))
    (!equalp (next-vector lexic) (make-array 6))))

(deftest core-test deflexeme-test ()
  (!equal (macroexpand-1 '(deflexeme if ("if")))
	  '(defparameter if (make-lexeme 'if '("if")))))

(deftest core-test nullable-test ()
  (!eq (nullable (regular-to-tree '((- "a" "d")))) nil)
  (!eq (nullable (regular-to-tree '((* "a")))) t)
  (!eq (nullable (regular-to-tree '((? "ab")))) t)
  (!eq (nullable (regular-to-tree '((* "ab") (? "cd") "ef"))) nil)
  (!eq (nullable (regular-to-tree '((* "ab") (? "cd") (|| "ef" "gh" (? "ij"))))) t)
  (!eq (nullable (final-node 'end)) nil))

(deflexeme if ("if"))
(deflexeme then ("then"))
(deflexeme word ((+ (- "a" "z"))))
(deflexeme integer ((? (|| "-" "+")) (+ (- "0" "9"))))
(deflexeme spaces ((* " ")))
(deflexeme r-word ((+ (- "а" "я"))))

(deftest core-test first-test ()
  (!equal (first-pos (expression (make-lexic if))) '(0))
  (!equal (first-pos (expression (make-lexic word))) '(0))
  (!equal (first-pos (expression (make-lexic integer))) '(0 1 2))
  (!equal (first-pos (expression (make-lexic spaces))) '(0 1)))

(deftest core-test last-test ()
  (!equal (last-pos (expression (make-lexic if))) '(2))
  (!equal (last-pos (expression (make-lexic (burning-lexical::left-node word))))
	  '(0 1))
  (!equal (last-pos (expression (make-lexic (burning-lexical::left-node integer))))
	  '(2 3)))

(deflexic sample-lexic (make-lexeme 'sample '((* (- "a" "b")) "abb")))

(deftest core-test follow-test ()
  (!equalp (follow-vector sample-lexic)
	   #((0 1 2) (0 1 2) (3) (4) (5) ())))

(deftest core-test lexic-generation ()
  (!node= (expression sample-lexic) 
	  (and-node (and-node (star-node (or-node (irange-node 0 0) 
						  (irange-node 1 1)))
			      (and-node (irange-node 0 2) 
					(and-node (irange-node 1 3) 
						  (irange-node 1 4))))
		    (p-final-node 'sample 5)))
  (!equalp (follow-vector sample-lexic) #((0 1 2) (0 1 2) (3) (4) (5) ()))
  (!equalp (value-vector sample-lexic) #(nil nil nil nil nil sample))
  (!equalp (next-vector sample-lexic) #(0 1 0 1 1 nil)))
